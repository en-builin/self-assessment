# Нарушение принципов SOLID в JDK, Spring и паттернах

## SRP

### Практически любой Util-класс

Например, `Collections` содержит методы манипуляции с данными коллекций (поиск, сортировка, развороты) и статические методы, возвращающие синхронизированные и немодифицируемые обертки, пустые коллекции, синглтон-коллекции. Это - много ответственностей.

_Но почему так сделано очень даже понятно - для удобства пользователей кода._

### POJO, DTO

POJO, который выполняет не только функции value-класса, но также содержит методы операций над данными этого класса (методы кроме сеттеров и геттеров).

Пример, который я встречал - включение в DTO методов маппинга entity на DTO. Формально это нарушение SRP, и в паттернах Фаулера DTO не содержит в себе ничего кроме полей. Но и запрета на наличие методов я у него не помню.

_Я с этим социально-значимым ответом не согласен. Не понимаю чем плохо включить в DTO методы простого маппинга (да, MapStruct в проекте нет) - при изменении полей DTO нам точно придется менять маппинг, при изменении маппинга мы никому не помешаем, если закоммитим DTO. Да, маппинг может стать сложным в какой-то момент. Но из-за "когда-то может" мы сразу усложним структуру для пользователя кода._

### Классы коллекций

Строго говоря реализации коллекций имплементируют и хранение данных в соответствующей структуре (динамический массив, хеш-таблица) и методы манипуляции с данными - слияния, замены.

_Наверное я ошибаюсь и это не нарушение SRP, не могли же инженеры Sun ошибаться? Но тогда опять же непонятно, почему нельзя в дата-класс добавить методов._

### LocalDateTime

Класс `LocalDateTime` содержит методы работы с датой и временем и метод форматирования значения времени. На мой взгляд, формально его там не должно быть. Но где он мог бы быть я не знаю. Возможно в классе `DateTimeFormatter`.  

### GoF паттерн Singleton

Класс, реализованный по этому шаблону выполняет две ответственности - отвечает за свой жизненный цикл (контролирует, что он существует в единственном экземпляре) и непосредственно выполняет свои функции.

### Controller в Spring

Контроллер достаточно легко приготовить так, что в него протечет бизнес-логика, особенно если контроллер большой. Если у контроллера в зависимостях есть что-то кроме *Service - скорее всего он протек. Так могут делать, потому что это проще, чем рефакторить сервис-слой, но контроллер перестает выполнять одну функцию - связывать входящие запросы с логикой.

Сюда же можно отнести контроллеры, которые управляют несколькими конечными узлами (клиенты и заказы в одном контроллере). Нужно обратить внимание на то, сколько сервисов в зависимостях у контроллера.

### Service-слой

В проектах сервис-слой может раздуваться до больших размеров и реализовывать обычное процедурное программирование, может кроме бизнес-логики работать с БД, маппингом и пр. Нужно вспомогательную логику выносить во вспомогательные бизнес-классы, например, `KafkaService`.

_Я думаю, если в сервисном слое есть работа с `MongoTemplate` или `KafkaTemplate`, то это нарушение SRP. Но и создавать новый класс на каждый чих - как потом по ним ориентироваться... Больше вопросов чем ответов. Если сервис зависит только от своего репозитория и других сервисами - это же ок? Например, `ClientService` имеет в зависимостях `ClientRepository`, `OrderService`, `AccountBalanceService`. А если к этому добавляется `OrderRepository` и `AccountBalanceRepository` и AccountStatusRepository, это же нарушение? Насколько строгим должно быть соблюдение SRP?_

## OCP

### Неправильно приготовленные контроллеры и бизнес-слой

Если не соблюдать SRP и DIP, мы получим в классе (например, в контроллере) множество зависимостей и не сможем расширять его функционал без доработки контроллера. При любом изменении каждого сервис-класса, репозитория, нам нужно будет вносить изменения в контроллер. Если мы правильно разделим слои по ответственности, выделим интерфейсы, необходимые для взаимодействия, то мы сможем вводить новые реализации интерфейсов без изменения в вызывающем классе (контроллере). Введя интерфейс мы также изолируем наш контроллер от протекания в него информации о реализации бизнес-слоя, мы можем вносить изменения в текущую реализацию, не изменяя сам контроллер.

### Использование наследования при добавлении функциональности

Например, нам нужно добавить функциональность к классу, к конкретной реализации. Например, это класс коллекции `PriorityQueue` и нам нужно сделать свой вариант, `BoundedPriorityQueue`. Если используем наследование, мы переопределим часть методов. Но в этом случае при добавлении в исходную реализации функционала (новых методов), мы можем получить некорректную работу, т.к. эти методы буду доступны пользователям нашего класса.

Если же сделать композицию и добавить поле с типом `PriorityQueue`, то необходимый функционал мы сможем реализовать, и только он будет доступен пользователям. Т.к. API JDK всегда обратно совместимо, при возможных изменениях в оригинальной PriorityQueue наш класс будет устойчив к этим изменениям. Я считаю, это проявление OCP - `PriorityQueue` могут изменить в JDK, мы получим эти изменения под капотом, но нам ничего в своей `BoundedPriorityQueue` менять не нужно.

### Нарушения OCP в библиотеках

Не нашел, основной принцип соблюдения - выделение интерфейсов, чтобы можно было менять реализации и не допускать транзитивные зависимости, что и сделано и JDK и в Spring.

_Не понимаю, почему транзитивные зависимости обязательно протекут в вызывающий класс, если мы будем зависеть от конкретного класса, а не от интерфейса. Не могу придумать такой пример, не встречал._

## LSP

### Пример с квадратом и прямоугольником

Если реализовать дизайн кода таким образом, что прямоугольник унаследован от квадрата, то прямоугольник нельзя будет передать в тот код, который использует квадрат (у прямоугольника две длины сторон, а код рассчитывал на то, что длина одна). Если сделать наоборот - тоже получим проблему, т.к. код может устанавливать каждую сторону по отдельности и получить неожиданное поведение (сторона квадрата будет установлена только один раз).

С точки зрения приложения, а не математики, эти классы не выполняют семантику "IS A", они оба являются фигурами и их можно унаследовать от общей абстракции Shape, при необходимости определив в ней контракт методов, общих для всех фигур в программе. Например, методы вычисления площади или длины периметра.

### java.util.List.copyOf(Collection)

Метод падает при передаче в качестве параметра коллекции, содержащей null-элементы. Да, это написано в справке (контракте), но мы передаём коллекцию, которая может содержать null, но работоспособна, получаем `NPE`.

_Вообще этот принцип не только про наследование, но и про то, что реализованная логика (бизнес-логика) не должна противоречить логике родительского класса. Верно?_

## ISP

### Sonar API для плагинов (наверняка не только у Sonar есть эта проблема)

Классы плагина нужно унаследовать от абстракций в библиотеке API. При этом если какой-то метод не нужен, или мы не знаем как его реализовать, то оставляем реализацию пустой (`// NOOP`) или бросаем исключение. Если нам при наследовании попадается метод, который мы не может реализовать или нам его реализовывать не нужно, значит абстракция спроектирована с нарушением ISP.

### Интерфейсы коллекций JDK

Интерфейсы коллекций JDK определяют для коллекции методы и для добавления и для удаления. В случае реализации неизменяемой коллекции, или коллекции, в которой нельзя удалять записи, часть методов будет не будет реализована или будет бросать `UnsupportedOperationException`. Если бы интерфейсы были разделены, эти методы не пришлось бы реализовывать.

_Правильно ли я понимаю, что определить нарушается или нет ISP можно не по наличию методов в интерфейсе, а по тому, как мы будем этими методами пользоваться. Если у нас не возникнет необходимости использовать только часть методов, то ISP не нарушается?_

## DIP

### Работа с конкретными реализациями, а не от интерфейсов

Для коллекций в Java существуют интерфейсы, зависимости нужно делать от этих интерфейсов, а не от реализаций (тип переменных). В этом случае мы не сможем использовать в своем клиентском коде специфические методы конкретной реализации. Как один из вариантов, если нам нужна очередь, то нужно лучше использовать интерфейс Deque реализации `LinkedList`, чем `List` или напрямую `LinkedList` и в клиенте реализовывать логику на методах списка.

При разработке своей структуры классов выделяя интерфейс мы определяем внешний контракт наших слоев. Нам проще контролировать связи между слоями и классами, чем при зависимостях от реализаций

Пример нарушения и решения в `src/main/java/dip`
